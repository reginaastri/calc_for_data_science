---
title: "Partial Derivatives"
author: "W. Bauer"
date: "03/03/2015"
output: html_document
---

```{r echo=FALSE, warning=FALSE, message=FALSE}
# load package numDeriv, installing if necessary
if(!require(numDeriv)){
  install.packages("numDeriv")
  library(numDeriv)
  }
source("../R/utilities.R")
source("../R/maungaWhau.R")
```

1. The point of this unit is to introduce partial derivatives in a general setting.
    + Previously, we noted the simplest example of a derivative is the slope of a line.
    + We also noted that the closer you look at a smooth curve, the more it looks like a line. This allows us to assign a slope at any point on a smooth curve by taking a limit.
    ```{r fig.show='hold', fig.align='center', echo=FALSE}
makegrid(0:4, ylab="f(x)", major_axes=FALSE, main="Derivative of a function of 1 variable", cex.lab=2)
local({
  x <- seq(0,4,by=.1)
  y <- 2*sin(pi*x/4)
  lines(x, y, lwd=3)
  y1 <- 2*sin(pi*1.5/4)
  slope <- (pi/2)*cos(pi*1.5/4)
  y2 <- y1 + slope
  points(1.5, y1, pch=19, col="blue", cex=2.0)
  arrows(1.1, y1-.4*slope, 2.5, y2, lwd=3, col="blue")
  text(.25, 3.0, expression(over(d*f(x), d*x) %==% lim(over(f(x + Delta*x) - f(x), Delta*x), Delta*x %->% 0)), pos=4)
  })
```
    + **Perhaps we should introduce grad here** and run through exercises which numerically demonstrate common derivatives such as $\frac{d}{dx}e^x=e^x$, $\frac{d}{dx}sin(x)=cos(x)$, $\frac{d}{dx}x^2=2x$ and so on. For example, `deriv_sin <- sapply(seq(0,2*pi, by=.1), function(x)grad(sin,x))` could be plotted and compared with a plot of `cos(x)`. That such relations can be shown analytically should be mentioned. Possibly one analytic derivation might be presented in a plotmath figure.

2. Gradients on Maunga Whau
    + The previous example involved a function, f(x), of one variable, x.
    + In general, we may have functions of several variables, such as this topographic map of Maunga Whau volcano. Here f(x, y) is altitude, x is northward distance from a reference point, and y is westward distance from the reference point.
    ```{r fig.show='hold', fig.align='center', echo=FALSE}
  bg <- par("bg")
  par(bg = "lightblue")
  res <- persp(x, y, z, theta = 120, phi = 15, col = fill, scale = FALSE, xlab="x (South to North)", ylab="y (East to West)", zlab = "f(x, y)")
  title(main="Maunga Whau\nOne of 50 Volcanoes in the Auckland Region.", font.main = 4)
  par(bg=bg)
```
    + For this case there are *partial derivatives* in which estimate the slope with respect to one variable while holding the others constant.
    ```{r fig.show='hold', fig.align='center', echo=FALSE}
plot(0:1, 0:1, type='n', xlab="", ylab="", main="Partial Derivatives", xaxt='n', yaxt='n', bty='n')
text(0, 0.8, expression(over(partialdiff*f(x,y), partialdiff*x) %==% lim(over(f(x + Delta*x, y) - f(x, y), Delta*x), Delta*x %->% 0)), pos=4, cex=1.5)
text(0, 0.2, expression(over(partialdiff*f(x,y), partialdiff*y) %==% lim(over(f(x, y + Delta*y) - f(x, y), Delta*y), Delta*y %->% 0)), pos=4, cex=1.5)
```
    + At a point on Maunga Whau, the partial derivatives represent slope in the x and y directions respectively. In the case pictured, the longer arrow represents slope in the x, or northward, direction. In this direction, the slope is clearly negative, or downhill. In the y, or westward, direction the slope is much less severe and is slightly uphill as the shorter arrow illustrates.  
    ```{r fig.show='hold', fig.align='center', echo=FALSE}
bg <- par("bg")
par(bg="lightblue")
res <- persp(x, y, z, theta = 120, phi = 15, col = fill, scale = FALSE, box=FALSE, main="Partial Derivatives")
par(bg=bg)
myx <- 89-16# 89-15
myy <- 63-42 # 63-32
myloc <- trans3d(x[myx], y[myy], z[myx, myy], res)
points(myloc$x, myloc$y, pch=19, cex=1.5, col="yellow")
dfdx <- (z[myx+1, myy]-z[myx, myy])/10
mydx <- trans3d(x[myx+5], y[myy], z[myx, myy] + dfdx*50, res)
arrows(myloc$x, myloc$y, mydx$x, mydx$y, lwd=3, col="yellow")
dfdy <- (z[myx, myy+1]-z[myx, myy])/10
mydy <- trans3d(x[myx], y[myy+5], z[myx, myy] + dfdy*50, res)
arrows(myloc$x, myloc$y, mydy$x, mydy$y, lwd=3, col="yellow")
```
    + As illustrated in the figure, the *gradient* of a function is a vector of its partial deriviatives. It is usually symbolized by a nabla (upside down triangle.)
    ```{r fig.show='hold', fig.align='center', echo=FALSE}
plot(0:1, 0:1, type='n', xlab="", ylab="", main="Gradient of f(x,y)", xaxt='n', yaxt='n', bty='n')
text(.5, .5, expression(nabla*f(x, y) %==% bgroup("(",atop(over(partialdiff*f(x,y), partialdiff*x), over(partialdiff*f(x,y), partialdiff*y)),")")), cex=2)
```
    + It can be shown that the gradient indicates the magnitude and direction of steepest incline. The gradient at that same point on Maunga Whau is shown here in pink.
    ```{r fig.show='hold', fig.align='center', echo=FALSE}
bg <- par("bg")
par(bg="lightblue")
res <- persp(x, y, z, theta = 120, phi = 15, col = fill, scale = FALSE, box=FALSE, main="Gradient at a Point on Maunga Whau")
par(bg=bg)
myx <- 89-16# 89-15
myy <- 63-42 # 63-32
myloc <- trans3d(x[myx], y[myy], z[myx, myy], res)
points(myloc$x, myloc$y, pch=19, cex=1.5, col="yellow")
dfdx <- (z[myx+1, myy]-z[myx, myy])/10
mydx <- trans3d(x[myx+5], y[myy], z[myx, myy] + dfdx*50, res)
arrows(myloc$x, myloc$y, mydx$x, mydx$y, lwd=2, col="yellow")
dfdy <- (z[myx, myy+1]-z[myx, myy])/10
mydy <- trans3d(x[myx], y[myy+5], z[myx, myy] + dfdy*50, res)
arrows(myloc$x, myloc$y, mydy$x, mydy$y, lwd=2, col="yellow")
grd <- trans3d(x[myx+5], y[myy+5], z[myx, myy] + (dfdx+dfdy)*50, res)
arrows(myloc$x, myloc$y, grd$x, grd$y, lwd=4, col='pink')
```
    + Gradients can be estimated using the function, `grad`, in package numDiff.
    + It takes two arguments, a function and a point at which the gradient of the function is to be estimated.
    + So grad is a function of another function and a point.
    + The point must be represented by a vector.
    + The function, grad's first argument, is an R function which takes a vector argument and returns the value at the point represented by the vector.
    + We've written `mw(point)` which gives the altitude of Maunga Whau as a function of point coordinates. (Actually it gives twice the altitude, since that's the way z is calibrated.)
    + Illustrate the use of `mw` by finding the altitude at the pictured points.
    ```{r fig.show='hold', fig.align='center', echo=FALSE}
place <- function(i, j, res, col="yellow"){
  temp <- trans3d(x[i], y[j], z[i,j], res)
  points(temp$x, temp$y, pch=19, cex=1.5, col=col)
  text(temp$x, temp$y, paste0("c(",x[i],",",y[j],")"), pos=3, col=col, lwd=2)
}
bg <- par("bg")
par(bg="lightblue")
res <- persp(x, y, z, theta = 120, phi = 15, col = fill, scale = FALSE, box=FALSE, main="Points and Gradients on Maunga Whau")
par(bg=bg)
place(68,32,res)
place(59,40,res)
place(37,47,res)
```
    
    ```{r}
mw(c(670, 310))
mw(c(580, 390))
mw(c(360, 460))
```
    + Illustrate `grad` by finding the gradient at those same points
    ```{r}
grad(mw,c(670, 310))
grad(mw,c(580, 390))
grad(mw,c(360, 460))
```
    + The gradient at `c(670, 310)` is zero because that location is a *local maximum*, i.e., the top of a hill. Note that it is not the highest point on the map, hence is called local.

3. Gradient of a function of 3 variables.
    + Planets, asteroids, comets, and other small bodies travel in approximately elliptical orbits around the sun. Their speed at any point in their orbit is determined by their mass, $m$, their distance, $r$, from the sun, the length, $a$ of their orbit's major axis, and the gravitational constant, $G.$
    +
    ```{r fig.show='hold', fig.align='center', echo=FALSE}
mai <- par("mai")
par(mai=adj_margins())
plot(-1:1, -1:1, type='n', xlab='', ylab='', main="Elliptical Orbit", xaxt='n', yaxt='n', bty='n')
par(mai=mai)
rect(-1,-1,1,1,col="black")
orb <- ellipse(.38, matrix(c(2, 0, 0, 1), 2, 2))
polygon(orb, border="lightblue", lwd=3)
segments(-.77, 0, .77, 0, lty=2, lwd=2, col="lightblue")
text(0,0,"a", pos=1, cex=1.2, col="white")
sun <- ellipse(.15)
sunoffset <- .45
sun[,1] <- sun[,1] + sunoffset
planet <- ellipse(.04)
planet[,1] <- planet[,1]+orb[20,1]
planet[,2] <- planet[,2]+orb[20,2]
segments(orb[20,1], orb[20,2], sunoffset, 0, lty=2, lwd=2, col="lightblue")
text(mean(c(orb[20,1], sunoffset)), mean(c(orb[20,2], 0)), "r", pos=3, cex=1.2, col="white")
polygon(sun, border='red', col='yellow', lwd=6)
polygon(planet, border="skyblue", col="seagreen",lwd=3)
font <- par("font")
par(font=2)
text(-.8, .65, expression(v == sqrt(m*G*bgroup("(",over(2,r)-over(1,a),")"))), col="white", pos=4, cex=1.2)
par(font=font)
G <- 6.673e−11 # N·(m/kg)^2 
```